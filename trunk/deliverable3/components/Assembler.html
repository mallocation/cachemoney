<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Cache Money - Assembler</title>
<link rel="stylesheet" type="text/css" href="css/cache_money.css">
</head>

<body>
<a name="Top"></a>
<div id="description">
	<table width="600">
	<tr>
		<td>
			<h2>Assembler</h2>
			<a href="Assembler.zip">Assembler.zip</a> [1570 KB]
			<br>
			<br>
			1.) <a href="#Contents">Contents of Assembler.zip</a><br>
			2.) <a href="#Documentation">Assembler Documentation</a><br>
			<div style="padding-left:20px;">
				a.) <a href="#GUI">GUI</a><br>
				b.) <a href="#Parsing">Instruction Parsing</a><br>
			</div>
			3.) <a href="#Compile">How to compile on CSE</a><br>
			4.) <a href="#Program">Matrix Multiplication Program</a><br>
			<br>
		</td>
	</tr>
	<tr>
		<td>
		<a name="Contents"></a><h5>Contents of Assembler.zip &nbsp;<a href="#Top">(Back to top)</a></h5>
		<div style="padding-left:25px;">
			/design/<br>
			<div style="padding-left:25px;">
				The design folder consists of a few preliminary GUI pictures, assemblergui.jpg, and 
				matricesinasm.jpg as well as the UML diagram of our finished assembler design,
				AssemblerUML.vsd.
			</div>
			/src/<br>
			<div style="padding-left:25px;">
				The src folder consists of the source code for our assembler. The source code is broken
				up into several folders: One for the GUI (Graphical User Interface) code, one for 
				instruction code, one for interfaces, and one for Utilities. 
			</div>
			multwreg.asm<br>
			<div style="padding-left:25px;">
				This is our input file, the matrix multiplication program, which runs the square
				matrix multiplication algorithm on the data set provided at the end of the file.
			</div>
		</div>
		</td>
	</tr>
	<tr>
		<td>
			<a name="Documentation"></a><h5>Documentation &nbsp;<a href="#Top">(Back to top)</a></h5>
			Our assembler was written in Java. From the beginning, the assembler was broken
			up into two parts, the GUI, and the actual instruction parsing. 
			<br>
			<br>
		</td>
	</tr>
	<tr>
		<td style="padding-left:50px;">
<a name="GUI"></a>	1. The GUI &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Top">(Back to top)</a>
			<table>
				<tr>
					<td style="padding-left:25px;" align=justify>
						Our GUI contains two panels: One to display the contents of the .asm input file,
						and one to display the contents of our output which is the generated mif file. 
						When the user enters the .asm file, it is displayed on the .asm panel. When the user
						chooses to generate the .mif file, the user is prompted for a location to save.
						Once the user specifies a save file, the text of the generated .mif file is displayed
						on the .mif textarea. 
						<br><br>
						<img alt="GUI Screenshot" src="images/gui.png">
						<br>
						It is possible that our GUI will throw exceptions if an incorrect type of input
						file is provided but it is important to note that the scope of the assembler is to handle
						a .asm file that is designed to be assembled by the Cache_Money assembler and the output
						is designed to work on the Cache_Money processor, using only the Cache_Money instruction set.
						<br>
					</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<td style="padding-left:50px;">
<a name="Parsing"></a>	2. Instruction Parsing + Instruction and data layout &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Top">(Back to top)</a>
			<table>
				<tr>
					<td style="padding-left:25px;" align=justify>
						The instruction parsing of the assembler works such that first all comments, denoted
						by text following a pound symbol, are removed from the code. The .mif file starts
						out with the initialization lines which define the width and depth our code. The width
						is the same as the number of bits of our instruction (32 bits) and the depth is (512*2^13)/32
						 = 131072 bits!
						<br>
						<br>
						Once the comments are removed and the initialization lines are added, the assembler 
						calculates the symbolic addresses, then the instructions are parsed, converting them from
						assembly code to byte code which can then be interpreted by our processor. The symbolic
						addresses are determined first because certain instructions (lw, sw, and addi) will need
						to know where from to fetch/place values in memory.
						<br>
						<br>
						The .asm file is to be organized so that instructions come first, then the data which is stored
						in symbolic references. There are two types of symbolic references as identified by our assembler,
						".array" which consist of several values delimited by commas and ".integer" which consists of
						a single integer value. In the case of matrix multiplication, the user will first specify the assembly code
						that will perform the matrix multiplication computations, followed by the data section. The data section is
						specified by a line that reads ".data" followed by the data itself which consists of: .size  section which
						specifies n for two n by n matricies (a ".integer" symbolic reference), followed by each matrix in ".array"
						 form. The matricies should be entered row by row, left to right. In the symbolic references this can be
						 done by the following example:
						<pre>add $3, $0, $1<br>...<br>.data #specifies the beginning of the data section<br>size: .integer 3<br>matrix1: .array 1,2,3,4,5,6,7,8,9<br>matrix2: .array 3,6,5,4,7,8,9,4,1<br>matrix3: .integer 0</pre>
						<img src="images/matricies.jpg"><br>
						(Note here that having matrix3 after matrix2 simply lets us know where to store the
						 computed values as we are performing the matrix multiplication)<br><br>
						In order to access the address of the instructions, we have modified the addi instruction so that if
						a user specifies a symbolic reference location to add to a register, the value that will go in the 
						register will be the address of the symbolic reference. For example, the following instruction:
						<pre>addi $29, $0, matrix1	#Load the base address of the first matrix</pre>
						would translate to the following byte code:
						<pre>1 : 00111101000000000000000000011011;</pre>
						Where the last 19-bits represent the immediate field. In this case, the last bits represent the address
						of matrix1 which is 11011 (binary) -> 1B (hex). Line 1B is as follows in the .mif output file:
						<pre>1B : 00000000000000000000000000000001;</pre>
						
						
					</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<td>
			<a name="Compile"></a><h5>Compilation on CSE &nbsp;<a href="#Top">(Back to top)</a></h5>
			<div style="padding-left:25px;" align=justify>
			To compile our source code on CSE, one must follow these steps:

			</div>
		</td>
	</tr>
	<tr>
		<td>
			<a name="Program"></a><h5>Matrix Multiplication Program &nbsp;<a href="#Top">(Back to top)</a></h5>
			<div style="padding-left:25px;" align=justify>
				The matrix multiplication program written is based on the square matrix multiplication
				algorithm. The program contains 3 nested loops that perform the matrix multiplication 
				computation. After it computes a value, it stores it into the resultant matrix, in
				memory. From there we will be able to use those values to find the sum of the diagonal,
				which will be computed then displayed on the lcd.
			</div>
		</td>
	</tr>
	</table>
</div>

</body>

</html>
